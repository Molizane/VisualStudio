unit pxlib;

{$MODE Delphi}

{**************************************************************************}

{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.2 (c) 1997-2006 by Bob Swart (aka Dr.Bob - www.drbob42.com)}
{    Refactored Delphi-Jedi (Darth) command-line/GUI units edition         }

{    Generated Date: 14/05/2018                                            }
{    Generated Time: 13:36:06                                              }

{**************************************************************************}

interface

uses
  {$IFDEF WIN32}
  Windows;
  {$ELSE}
   LCLIntf, LCLType, LMessages;
  {$ENDIF}

{> C:\Angelo\Pascal\Delphi\Progs\pxlibtst\PXLIB-DRAFT.H <=}

(*
{$IFNDEF __PARADOX_H__}
{$DEFINE __PARADOX_H__}

const
  PX_USE_RECODE = 0;
  PX_USE_ICONV = 0;

{$INCLUDE <stdio.h>}
{$IFDEF PX_USE_RECODE}
{$INCLUDE <recode.h>}
{$ELSE}
{$IFDEF PX_USE_ICONV}
{$INCLUDE <iconv.h>}
{$ENDIF}
{$ENDIF}

{$IFDEF WIN32}
const
  PXLIB_DLL = 1;
  PXLIB_EXPORTS = 1;
  PXLIB_CALL = __cdecl;

{$IFDEF PXLIB_EXPORTS}
  PXLIB_API = __declspec(dllexport); // prepare a DLL (internal use only)
{$ELSE PXLIB_DLL}
  PXLIB_API = __declspec(dllimport); // PXlib clients: import PXlib DLL
{$ELSE /* !PXLIB_DLL
  PXLIB_API =; //*/ /* default: generate or use static library

{$ENDIF /* !PXLIB_DLL
{$ENDIF /* !WIN32
{$IFNDEF PXLIB_CALL}
{$DEFINE PXLIB_CALL}
{$ENDIF}
{$IFNDEF PXLIB_API}
{$DEFINE PXLIB_API}
{$ENDIF}
*)

const
  px_true = 1;
  px_false = 0;

// Error codes
const
  PX_MemoryError = 1;
  PX_IOError = 2;
  PX_RuntimeError = 3;
  PX_Warning = 100;

// IO Stream types
const
  pxfIOFile = 1;
  // pxfIOGsf is defined as 2 in paradox-gsf.h
  pxfIOStream = 3;

// Field types
const
  pxfAlpha = $01;
  pxfDate = $02;
  pxfShort = $03;
  pxfLong = $04;
  pxfCurrency = $05;
  pxfNumber = $06;
  pxfLogical = $09;
  pxfMemoBLOb = $0C;
  pxfBLOb = $0D;
  pxfFmtMemoBLOb = $0E;
  pxfOLE = $0;
  pxfGraphic = $10;
  pxfTime = $14;
  pxfTimestamp = $15;
  pxfAutoInc = $16;
  pxfBCD = $17;
  pxfBytes = $18;
  pxfNumTypes = $18;

// File types
const
  pxfFileTypIndexDB = 0; // .DB
  pxfFileTypPrimIndex = 1; // .PX
  pxfFileTypNonIndexDB = 2; // .DB
  pxfFileTypNonIncSecIndex = 3; // .Xnn
  pxfFileTypSecIndex = 4; // .Ynn
  pxfFileTypIncSecIndex = 5; // .Xnn
  pxfFileTypNonIncSecIndexG = 6; // .XGn
  pxfFileTypSecIndexG = 7; // .YGn
  pxfFileTypIncSecIndexG = 8; // .XGn

// File modes
const
  pxfFileRead = $1;
  pxfFileWrite = $2;

type
  PFILE = ^FILE_;

  FILE_ = packed record
    _Placeholder: Pointer;
  end;

  PXFIELD_T = ^px_field;

  px_field = packed record
    px_fname: PChar;
    px_ftype: byte;
    px_flen: integer;
    px_fdc: integer;
  end {px_field};

  px_string = packed record
    val: PChar;
    len: integer;
  end;

  px_val_ = packed record
    case integer of
      0: (lval: longint);
      1: (dval: double);
      2: (str: px_string);
  end;

  PXVAL_T = ^px_val;

  px_val = packed record
    isnull: byte;
    type_: integer;
    Value: px_val_;
  end {px_val};

  PXHEAD_T = ^px_head;

  px_head = packed record
    px_tablename: PChar;
    px_recordsize: integer;
    px_filetype: byte;
    px_fileversion: integer;
    px_numrecords: integer;
    px_theonumrecords: integer;
    px_numfields: integer;
    px_maxtablesize: integer;
    px_headersize: integer;
    px_fileblocks: word;
    px_firstblock: word;
    px_lastblock: word;
    px_indexfieldnumber: integer;
    px_indexroot: integer;
    px_numindexlevels: integer;
    px_writeprotected: integer;
    px_doscodepage: integer;
    px_primarykeyfields: integer;
    px_modifiedflags1: byte;
    px_modifiedflags2: byte;
    px_sortorder: byte;
    px_autoinc: integer;
    px_fileupdatetime: integer;
    px_refintegrity: byte;
    px_fields: PXFIELD_T;
    px_encryption: longint;
  end {px_head};

  px_stream_data = packed record
    case integer of
      0: (fp: PFILE);
      1: (stream: Pointer);
      {$IFDEF HAVE_GSF}
      2: (gsfin: PGSFINPUT);
      3: (gsfout: PGSFOUTPUT);
      {$ENDIF}
  end;

  PPXDOC_T = Pointer;
  PPXSTREAM_T = Pointer;
  PPXBLOB_T = Pointer;

  { input stream functions }
  // size_t ( *read)(pxdoc_t *p, PXSTREAM_T *stream, size_t numbytes, void *buffer);
  px_read = function(p: PPXDOC_T; stream: PPXSTREAM_T; numbytes: cardinal;
    buffer: Pointer): cardinal; stdcall;

  // int ( *seek)(pxdoc_t *p, PXSTREAM_T *stream, long offset, int whence);
  px_seek = function(p: PPXDOC_T; stream: PPXSTREAM_T; offset: longint;
    whence: integer): integer; stdcall;

  // long ( *tell)(pxdoc_t *p, PXSTREAM_T *stream);
  px_tell = function(p: PPXDOC_T; stream: PPXSTREAM_T; numbytes: cardinal;
    buffer: Pointer): longint; stdcall;

  // size_t ( *write)(pxdoc_t *p, PXSTREAM_T *stream, size_t numbytes, void *buffer);
  px_write = function(p: PPXDOC_T; stream: PPXSTREAM_T; numbytes: cardinal;
    buffer: Pointer): cardinal; stdcall;

  PXSTREAM_T = ^px_stream;

  px_stream = packed record
    type_: integer; { set to pxfIOFile | pxfIOGsf | pxfIOStream }
    mode: integer; { set to pxfFileRead | pxfFileWrite }
    Close: integer; { set to true if stream must be closed }
    s: px_stream_data;
    Read: px_read;
    seek: px_seek;
    tell: px_tell;
    Write: px_write;
  end;

  { output function }
  //size_t ( *writeproc)(pxdoc_t *p, void *data, size_t size);
  px_writeproc = function(p: PPXDOC_T; Data: Pointer; size: cardinal): cardinal; stdcall;

  { error handler function }
  //void ( *errorhandler)(pxdoc_t *p, int level, const char* msg, void *data);
  px_errorhandler = procedure(p: PPXDOC_T; level: integer; msg: PChar;
    Data: Pointer); stdcall;

  { Memory allocation functions }
  //void *( *malloc)(pxdoc_t *p, size_t size, const char *caller);
  px_malloc = function(p: PPXDOC_T; size: cardinal; caller: PChar): Pointer; stdcall;

  //void *( *calloc)(pxdoc_t *p, size_t size, const char *caller);
  px_calloc = function(p: PPXDOC_T; size: cardinal; caller: PChar): Pointer; stdcall;

  //void *( *realloc)(pxdoc_t *p, void *mem, size_t size, const char *caller);
  px_realloc = function(p: PPXDOC_T; mem: Pointer; size: cardinal;
    caller: PChar): Pointer; stdcall;

  //void ( *free)(pxdoc_t *p, void *mem);
  px_free = procedure(p: PPXDOC_T; mem: Pointer); stdcall;

  PXDOC_T = ^px_doc;

  px_doc = packed record
    { database file }
    // FILE*px_fp; { File pointer of file }
    px_stream: PXSTREAM_T; { input stream to read file from }
    px_name: PChar; { Name of file }
    px_close_fp: integer; { set to true if file pointer must be closed, deprecated }
    // int px_filemode; { set to pxfFileRead|pxfFileWrite }
    px_head: PXHEAD_T; { Pointer to header of file }
    px_data: Pointer; { Pointer to data of file (used in prim. index for }
    { index data, used in db files for an self build }
    { index) }
    px_datalen: integer; { length of data field in number of units }
    px_indexdata: Pointer; { Pointer to index data }
    px_indexdatalen: integer; { number of index data records }

    // primary index file
    px_pindex: PXDOC_T;

    // blob file
    px_blob: PPXBLOB_T;

    // record accounting
    last_position: integer; { Position (starting at 0) where last record was put. }

    warnings: integer; { Turn of/off output of warnings }

    { output function}
    writeproc: px_writeproc; { error handler function }
    errorhandler: px_errorhandler;

    // user data passed to error handler
    errorhandler_user_data: Pointer;

    { Memory allocation functions }
    malloc: px_malloc;
    calloc: px_calloc;
    realloc: px_realloc;
    Free: px_free;

    { input stream functions }
    Read: px_read;
    seek: px_seek;
    tell: px_tell;
    Write: px_write;

    targetencoding: PChar;
    inputencoding: PChar;

    {$IFDEF PX_USE_RECODE}
    recode_outer: RECODE_OUTER;
    out_recode_request: RECODE_REQUEST; { Encoding of written data }
    in_recode_request: RECODE_REQUEST; { Encoding of read data }
    {$ELSE}
    {$IFDEF PX_USE_ICONV}
    out_iconvcd: ICONV_T; { Encoding of written data }
    in_iconvcd: ICONV_T; { Encoding of read data }
    {$ENDIF}
    {$ENDIF}

    curblocknr: longint; { Number of current block in cache (0-n) }
    curblockdirty: integer; { Set to px_true if the block needs to be written }
    curblock: PByte; { Data of block in read cache }
  end {px_doc};

  PXBLOCKCACHE_T = ^px_blockcache;

  px_blockcache = packed record
    start: longint;
    size: cardinal;
    Data: PByte;
  end {px_blockcache};

  PXMBBLOCKINFO_T = ^px_mbblockinfo;

  px_mbblockinfo = packed record
    number: integer;
    type_: byte;
    numblobs: byte;
    numblocks: integer;
    allocspace: integer;
  end {px_mbblockinfo};

  MBHEAD_T = ^mb_head;

  mb_head = packed record
    modcount: integer;
  end {mb_head};

  PXBLOB_T = ^px_blob;

  px_blob = packed record
    mb_name: PChar;
    pxdoc: PXDOC_T;
    mb_stream: PXSTREAM_T; { input stream to read file from }
    mb_head: MBHEAD_T; { Pointer to header of file }
    used_datablocks: integer;
    subblockoffset: integer;
    subblockinneroffset: integer;
    subblockfree: integer;
    subblockblobcount: integer;

    { input stream functions}
    Read: px_read;
    seek: px_seek;
    tell: px_tell;
    Write: px_write;

    // Cache for the last read block
    blockcache: PXBLOCKCACHE_T;
    // Index of all blocks in the blob file
    blocklist: PXMBBLOCKINFO_T;
    blocklistlen: integer;
  end {px_blob};

  PXDATABLOCKINFO_T = ^px_datablockinfo;

  px_datablockinfo = packed record
    blockpos: longint; { the start of the block in the file }
    recordpos: longint; { the start of the record in the file }
    size: integer; { the size of the block }
    recno: integer; { the recno with the block starting with 0 }
    numrecords: integer; { the number of records in the block }
    prev: integer; { the number of the previous block }
    Next: integer; { the number of the next block }
    number: integer; { the block number count (first block is 1) }
  end {px_datablockinfo};

  px_pindex = packed record
    Data: PChar;
    blocknumber: integer; { Block number of referenced block }
    numrecords: integer;
    dummy: integer;
    myblocknumber: integer; { Number of block this record is stored in }
    level: integer; { level of index block, level 1 blocks point to }
    {* data block in the database file. }
  end {px_pindex};

  {
  #define MAKE_PXVAL(pxdoc, pxval) \
      (pxval) = (pxval_t *) (pxdoc)->malloc((pxdoc), sizeof(pxval_t), "Allocate memory for pxval_t"); \
      memset((void *) (pxval), 0, sizeof(pxval_t));

  #define FREE_PXVAL(pxdoc, pxval) \
      (pxdoc)->free((pxdoc), (pxval));
  }

function MAKE_PXVAL(pxdoc: px_doc): PXVAL_T;
procedure FREE_PXVAL(pxdoc: px_doc; pxval: px_val);

function PX_get_majorversion: integer; cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_get_minorversion: integer; cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_get_subminorversion: integer; cdecl;{$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_has_recode_support: integer; cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_has_gsf_support: integer; cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_is_bigendian: integer; cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_get_builddate: PChar; cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

procedure PX_boot(); cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

procedure PX_shutdown(); cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

type
  px_allocproc = function(p: PXDOC_T; size: cardinal; var caller: PChar): Pointer;
  px_reallocproc = function(p: PXDOC_T; mem: Pointer; size: cardinal;
    var caller: PChar): Pointer;
  px_freeproc = procedure(p: PXDOC_T; mem: Pointer);

{
PXLIB_API pxdoc_t* PXLIB_CALL
PX_new3(void  (*errorhandler)(pxdoc_t *p, int type, const char *msg, void *data),
        void* (*allocproc)(pxdoc_t *p, size_t size, const char *caller),
        void* (*reallocproc)(pxdoc_t *p, void *mem, size_t size, const char *caller),
        void  (*freeproc)(pxdoc_t *p, void *mem),
        void* errorhandler_user_data);
}
function PX_new3(errorhandler: px_errorhandler; allocproc: px_allocproc;
  reallocproc: px_reallocproc; freeproc: px_freeproc;
  errorhandler_user_data: Pointer): PXDOC_T; cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

{
PXLIB_API pxdoc_t* PXLIB_CALL
PX_new2(void  (*errorhandler)(pxdoc_t *p, int type, const char *msg, void *data),
        void* (*allocproc)(pxdoc_t *p, size_t size, const char *caller),
        void* (*reallocproc)(pxdoc_t *p, void *mem, size_t size, const char *caller),
        void  (*freeproc)(pxdoc_t *p, void *mem));
}
function PX_new2(errorhandler: px_errorhandler; allocproc: px_allocproc;
  reallocproc: px_reallocproc; freeproc: px_freeproc): PXDOC_T;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_new: PXDOC_T; cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_open_fp(pxdoc: PXDOC_T; var fp: FILE_): integer;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_open_file(pxdoc: PXDOC_T; filename: PChar): integer;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_create_file(pxdoc: PXDOC_T; var pxf: PXFIELD_T; numfields: integer;
  filename: PChar; type_: integer): integer;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_create_fp(pxdoc: PXDOC_T; var pxf: PXFIELD_T; numfields: integer;
  var fp: FILE_; type_: integer): integer; cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_get_opaque(pxdoc: PXDOC_T): Pointer; cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_write_primary_index(pxdoc: PXDOC_T; var pxindex: PXDOC_T): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_read_primary_index(var pindex: PXDOC_T): PInteger; cdecl;
 {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_add_primary_index(pxdoc: PXDOC_T; var pindex: PXDOC_T): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_get_record(pxdoc: PXDOC_T; recno: integer; Data: PBYTE): PBYTE;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_get_record2(pxdoc: PXDOC_T; recno: integer; Data: PBYTE;
  var deleted: integer; var pxdbinfo: PXDATABLOCKINFO_T): PBYTE;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_put_recordn(pxdoc: PXDOC_T; Data: PChar; recpos: integer): integer;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_put_record(pxdoc: PXDOC_T; Data: PChar): PInteger; cdecl;
 {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_insert_record(pxdoc: PXDOC_T; var dataptr: PXVAL_T): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_update_record(pxdoc: PXDOC_T; var dataptr: PXVAL_T;
  recno: integer): integer;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_delete_record(pxdoc: PXDOC_T; recno: integer): integer;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_retrieve_record(pxdoc: PXDOC_T; recno: integer): PXVAL_T;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

procedure PX_close(pxdoc: PXDOC_T); cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

procedure PX_delete(pxdoc: PXDOC_T); cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_pack(pxdoc: PXDOC_T): PInteger; cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_get_fields(pxdoc: PXDOC_T): PXFIELD_T; cdecl;
 {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_get_field(pxdoc: PXDOC_T; i: integer): PXFIELD_T; cdecl;
 {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_get_num_fields(pxdoc: PXDOC_T): PInteger; cdecl;
 {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_get_num_records(pxdoc: PXDOC_T): PInteger; cdecl;
 {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_get_recordsize(pxdoc: PXDOC_T): PInteger; cdecl;
 {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_set_parameter(pxdoc: PXDOC_T; Name: PChar; Value: PChar): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_get_parameter(pxdoc: PXDOC_T; Name: PChar; var Value: PChar): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_set_value(pxdoc: PXDOC_T; Name: PChar; Value: single): integer;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_get_value(pxdoc: PXDOC_T; Name: PChar; var Value: single): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_set_targetencoding(pxdoc: PXDOC_T; encoding: PChar): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_set_inputencoding(pxdoc: PXDOC_T; encoding: PChar): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_set_tablename(pxdoc: PXDOC_T; tablename: PChar): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_set_blob_file(pxdoc: PXDOC_T; filename: PChar): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_set_blob_fp(pxdoc: PXDOC_T; var fp: FILE_): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_has_blob_file(pxdoc: PXDOC_T): PInteger; cdecl;
 {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_new_blob(pxdoc: PXDOC_T): PXBLOB_T; cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_open_blob_fp(var pxdoc: PXBLOB_T; var fp: FILE_): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_open_blob_file(var pxdoc: PXBLOB_T; filename: PChar): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_create_blob_fp(var pxdoc: PXBLOB_T; var fp: FILE_): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_create_blob_file(var pxblob: PXBLOB_T; filename: PChar): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

procedure PX_close_blob(var pxdoc: PXBLOB_T); cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

procedure PX_delete_blob(var pxblob: PXBLOB_T); cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_read_blobdata(var pxblob: PXBLOB_T; Data: PChar; len: integer;
  var mode: integer; var blobsize: integer): PPChar;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_read_graphicdata(var pxblob: PXBLOB_T; Data: PChar;
  len: integer; var mode: integer; var blobsize: integer): PPChar;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_read_grahicdata(var pxblob: PXBLOB_T; Data: PChar;
  len: integer; var mode: integer; var blobsize: integer): PPChar;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

// Data conversion functions
// Functions to read data from a record

function PX_get_data_alpha(pxdoc: PXDOC_T; Data: PChar; len: integer;
  var Value: PChar): Integer; cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_get_data_bytes(pxdoc: PXDOC_T; Data: PChar; len: integer;
  var Value: PChar): Integer; cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_get_data_double(pxdoc: PXDOC_T; Data: PChar; len: integer;
  var Value: double): Integer; cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_get_data_long(pxdoc: PXDOC_T; Data: PChar; len: integer;
  var Value: longint): Integer; cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_get_data_short(pxdoc: PXDOC_T; Data: PChar; len: integer;
  var Value: smallint): Integer; cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_get_data_byte(pxdoc: PXDOC_T; Data: PChar; len: integer;
  Value: PChar): Integer; cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_get_data_bcd(pxdoc: PXDOC_T; Data: PByte; len: integer;
  Value: PByte): Integer; cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_get_data_blob(pxdoc: PXDOC_T; Data: PChar; len: integer;
  var mode: integer; var blobsize: integer; Value: PChar): Integer;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_get_data_graphic(pxdoc: PXDOC_T; Data: PChar; len: integer;
  var mode: integer; var blobsize: integer; Value: PChar): Integer;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

// Funktion to add data to a record

procedure PX_put_data_alpha(pxdoc: PXDOC_T; Data: PChar; len: integer; Value: PChar);
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

procedure PX_put_data_bytes(pxdoc: PXDOC_T; Data: PChar; len: integer; Value: PChar);
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

procedure PX_put_data_double(pxdoc: PXDOC_T; Data: PChar; len: integer; Value: double);
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

procedure PX_put_data_long(pxdoc: PXDOC_T; Data: PChar; len: integer; Value: integer);
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

procedure PX_put_data_short(pxdoc: PXDOC_T; Data: PChar; len: integer; Value: smallint);
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

procedure PX_put_data_byte(pxdoc: PXDOC_T; Data: PChar; len: integer; Value: byte);
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

procedure PX_put_data_bcd(pxdoc: PXDOC_T; Data: PChar; len: integer; Value: PChar);
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_put_data_blob(pxdoc: PXDOC_T; Data: PChar; len: integer;
  Value: PChar; valuelen: integer): integer; cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

procedure PX_SdnToGregorian(sdn: longint; var pYear: integer;
  var pMonth: integer; var pDay: integer); cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_GregorianToSdn(year: integer; month: integer; day: integer): longint;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_make_time(pxdoc: PXDOC_T; hour: integer; minute: integer;
  second: integer): PXVAL_T; cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_make_date(pxdoc: PXDOC_T; year: integer; month: integer;
  day: integer): PXVAL_T; cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_make_timestamp(pxdoc: PXDOC_T; year: integer; month: integer;
  day: integer; hour: integer; minute: integer; second: integer): PXVAL_T;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_timestamp2string(pxdoc: PXDOC_T; Value: double; format: PChar): PChar;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_time2string(pxdoc: PXDOC_T; Value: longint; format: PChar): PPChar;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_date2string(pxdoc: PXDOC_T; Value: longint; format: PChar): PPChar;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF}

function PX_strdup(pxdoc: PXDOC_T; str: PChar): PPChar; cdecl;
 {$IFDEF WIN32_} stdcall; {$ENDIF}

{* Local variables: }
{* tab-width: 4 }
{* c-basic-offset: 4 }
{* End: }
{* vim600: sw=4 ts=4 fdm=marker }
{* vim<600: sw=4 ts=4 }

function PX_get_majorversion: integer; cdecl; {$IFDEF WIN32_} stdcall;
 {$ENDIF} external 'pxlib.dll';

function PX_get_minorversion: integer; cdecl; {$IFDEF WIN32_} stdcall;
 {$ENDIF} external 'pxlib.dll';

function PX_get_subminorversion: integer; cdecl;{$IFDEF WIN32_} stdcall;
 {$ENDIF} external 'pxlib.dll';

function PX_has_recode_support: integer; cdecl; {$IFDEF WIN32_} stdcall;
 {$ENDIF} external 'pxlib.dll';

function PX_has_gsf_support: integer; cdecl; {$IFDEF WIN32_} stdcall;
 {$ENDIF} external 'pxlib.dll';

function PX_is_bigendian: integer; cdecl; {$IFDEF WIN32_} stdcall;
 {$ENDIF} external 'pxlib.dll';

function PX_get_builddate: PChar; cdecl; {$IFDEF WIN32_} stdcall;
 {$ENDIF} external 'pxlib.dll';

procedure PX_boot(); cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

procedure PX_shutdown(); cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_new3(errorhandler: px_errorhandler; allocproc: px_allocproc;
  reallocproc: px_reallocproc; freeproc: px_freeproc;
  errorhandler_user_data: Pointer): PXDOC_T; cdecl; {$IFDEF WIN32_} stdcall;
 {$ENDIF} external 'pxlib.dll';

function PX_new2(errorhandler: px_errorhandler; allocproc: px_allocproc;
  reallocproc: px_reallocproc; freeproc: px_freeproc): PXDOC_T;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_new: PXDOC_T; cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_open_fp(pxdoc: PXDOC_T; var fp: FILE_): integer;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_open_file(pxdoc: PXDOC_T; filename: PChar): integer;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_create_file(pxdoc: PXDOC_T; var pxf: PXFIELD_T; numfields: integer;
  filename: PChar; type_: integer): integer;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_create_fp(pxdoc: PXDOC_T; var pxf: PXFIELD_T; numfields: integer;
  var fp: FILE_; type_: integer): integer; cdecl; {$IFDEF WIN32_} stdcall;
 {$ENDIF} external 'pxlib.dll';

function PX_get_opaque(pxdoc: PXDOC_T): Pointer; cdecl; {$IFDEF WIN32_} stdcall;
 {$ENDIF} external 'pxlib.dll';

function PX_write_primary_index(pxdoc: PXDOC_T; var pxindex: PXDOC_T): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_read_primary_index(var pindex: PXDOC_T): PInteger; cdecl;
 {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_add_primary_index(pxdoc: PXDOC_T; var pindex: PXDOC_T): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_get_record(pxdoc: PXDOC_T; recno: integer; Data: PBYTE): PBYTE;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_get_record2(pxdoc: PXDOC_T; recno: integer; Data: PBYTE;
  var deleted: integer; var pxdbinfo: PXDATABLOCKINFO_T): PBYTE;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_put_recordn(pxdoc: PXDOC_T; Data: PChar; recpos: integer): integer;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_put_record(pxdoc: PXDOC_T; Data: PChar): PInteger; cdecl;
 {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_insert_record(pxdoc: PXDOC_T; var dataptr: PXVAL_T): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_update_record(pxdoc: PXDOC_T; var dataptr: PXVAL_T;
  recno: integer): integer;
  cdecl; {$IFDEF WIN32_} stdcall;
 {$ENDIF} external 'pxlib.dll';

function PX_delete_record(pxdoc: PXDOC_T; recno: integer): integer;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_retrieve_record(pxdoc: PXDOC_T; recno: integer): PXVAL_T;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

procedure PX_close(pxdoc: PXDOC_T); cdecl; {$IFDEF WIN32_} stdcall;
 {$ENDIF} external 'pxlib.dll';

procedure PX_delete(pxdoc: PXDOC_T); cdecl; {$IFDEF WIN32_} stdcall;
 {$ENDIF} external 'pxlib.dll';

function PX_pack(pxdoc: PXDOC_T): PInteger; cdecl; {$IFDEF WIN32_} stdcall;
 {$ENDIF} external 'pxlib.dll';

function PX_get_fields(pxdoc: PXDOC_T): PXFIELD_T; cdecl; {$IFDEF WIN32_} stdcall;
 {$ENDIF} external 'pxlib.dll';

function PX_get_field(pxdoc: PXDOC_T; i: integer): PXFIELD_T; cdecl;
 {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_get_num_fields(pxdoc: PXDOC_T): PInteger; cdecl;
 {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_get_num_records(pxdoc: PXDOC_T): PInteger; cdecl;
 {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_get_recordsize(pxdoc: PXDOC_T): PInteger; cdecl;
 {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_set_parameter(pxdoc: PXDOC_T; Name: PChar; Value: PChar): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_get_parameter(pxdoc: PXDOC_T; Name: PChar; var Value: PChar): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_set_value(pxdoc: PXDOC_T; Name: PChar; Value: single): integer;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_get_value(pxdoc: PXDOC_T; Name: PChar; var Value: single): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_set_targetencoding(pxdoc: PXDOC_T; encoding: PChar): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_set_inputencoding(pxdoc: PXDOC_T; encoding: PChar): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_set_tablename(pxdoc: PXDOC_T; tablename: PChar): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_set_blob_file(pxdoc: PXDOC_T; filename: PChar): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_set_blob_fp(pxdoc: PXDOC_T; var fp: FILE_): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_has_blob_file(pxdoc: PXDOC_T): PInteger; cdecl;
 {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_new_blob(pxdoc: PXDOC_T): PXBLOB_T; cdecl; {$IFDEF WIN32_} stdcall;
 {$ENDIF} external 'pxlib.dll';

function PX_open_blob_fp(var pxdoc: PXBLOB_T; var fp: FILE_): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_open_blob_file(var pxdoc: PXBLOB_T; filename: PChar): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_create_blob_fp(var pxdoc: PXBLOB_T; var fp: FILE_): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_create_blob_file(var pxblob: PXBLOB_T; filename: PChar): PInteger;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

procedure PX_close_blob(var pxdoc: PXBLOB_T); cdecl; {$IFDEF WIN32_} stdcall;
 {$ENDIF} external 'pxlib.dll';

procedure PX_delete_blob(var pxblob: PXBLOB_T); cdecl; {$IFDEF WIN32_} stdcall;
 {$ENDIF} external 'pxlib.dll';

function PX_read_blobdata(var pxblob: PXBLOB_T; Data: PChar; len: integer;
  var mode: integer; var blobsize: integer): PPChar;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_read_graphicdata(var pxblob: PXBLOB_T; Data: PChar;
  len: integer; var mode: integer; var blobsize: integer): PPChar;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_read_grahicdata(var pxblob: PXBLOB_T; Data: PChar;
  len: integer; var mode: integer; var blobsize: integer): PPChar;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_get_data_alpha(pxdoc: PXDOC_T; Data: PChar; len: integer;
  var Value: PChar): Integer; cdecl; {$IFDEF WIN32_} stdcall;
 {$ENDIF} external 'pxlib.dll';

function PX_get_data_bytes(pxdoc: PXDOC_T; Data: PChar; len: integer;
  var Value: PChar): Integer; cdecl; {$IFDEF WIN32_} stdcall;
 {$ENDIF} external 'pxlib.dll';

function PX_get_data_double(pxdoc: PXDOC_T; Data: PChar; len: integer;
  var Value: double): Integer; cdecl; {$IFDEF WIN32_} stdcall;
 {$ENDIF} external 'pxlib.dll';

function PX_get_data_long(pxdoc: PXDOC_T; Data: PChar; len: integer;
  var Value: longint): Integer; cdecl; {$IFDEF WIN32_} stdcall;
 {$ENDIF} external 'pxlib.dll';

function PX_get_data_short(pxdoc: PXDOC_T; Data: PChar; len: integer;
  var Value: smallint): Integer; cdecl; {$IFDEF WIN32_} stdcall;
 {$ENDIF} external 'pxlib.dll';

function PX_get_data_byte(pxdoc: PXDOC_T; Data: PChar; len: integer;
  Value: PChar): Integer; cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_get_data_bcd(pxdoc: PXDOC_T; Data: PByte; len: integer;
  Value: PByte): Integer; cdecl; {$IFDEF WIN32_} stdcall;
 {$ENDIF} external 'pxlib.dll';

function PX_get_data_blob(pxdoc: PXDOC_T; Data: PChar; len: integer;
  var mode: integer; var blobsize: integer; Value: PChar): Integer;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_get_data_graphic(pxdoc: PXDOC_T; Data: PChar; len: integer;
  var mode: integer; var blobsize: integer; Value: PChar): Integer;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

procedure PX_put_data_alpha(pxdoc: PXDOC_T; Data: PChar; len: integer; Value: PChar);
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

procedure PX_put_data_bytes(pxdoc: PXDOC_T; Data: PChar; len: integer; Value: PChar);
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

procedure PX_put_data_double(pxdoc: PXDOC_T; Data: PChar; len: integer; Value: double);
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

procedure PX_put_data_long(pxdoc: PXDOC_T; Data: PChar; len: integer; Value: integer);
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

procedure PX_put_data_short(pxdoc: PXDOC_T; Data: PChar; len: integer; Value: smallint);
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

procedure PX_put_data_byte(pxdoc: PXDOC_T; Data: PChar; len: integer; Value: byte);
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

procedure PX_put_data_bcd(pxdoc: PXDOC_T; Data: PChar; len: integer; Value: PChar);
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_put_data_blob(pxdoc: PXDOC_T; Data: PChar; len: integer;
  Value: PChar; valuelen: integer): integer;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

procedure PX_SdnToGregorian(sdn: longint; var pYear: integer;
  var pMonth: integer; var pDay: integer); cdecl; {$IFDEF WIN32_} stdcall;
 {$ENDIF} external 'pxlib.dll';

function PX_GregorianToSdn(year: integer; month: integer; day: integer): longint;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_make_time(pxdoc: PXDOC_T; hour: integer; minute: integer;
  second: integer): PXVAL_T; cdecl; {$IFDEF WIN32_} stdcall;
 {$ENDIF} external 'pxlib.dll';

function PX_make_date(pxdoc: PXDOC_T; year: integer; month: integer;
  day: integer): PXVAL_T; cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_make_timestamp(pxdoc: PXDOC_T; year: integer; month: integer;
  day: integer; hour: integer; minute: integer; second: integer): PXVAL_T;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_timestamp2string(pxdoc: PXDOC_T; Value: double; format: PChar): PChar;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_time2string(pxdoc: PXDOC_T; Value: longint; format: PChar): PPChar;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_date2string(pxdoc: PXDOC_T; Value: longint; format: PChar): PPChar;
  cdecl; {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

function PX_strdup(pxdoc: PXDOC_T; str: PChar): PPChar; cdecl;
 {$IFDEF WIN32_} stdcall; {$ENDIF} external 'pxlib.dll';

implementation

function MAKE_PXVAL(pxdoc: px_doc): PXVAL_T;
begin
  Result := pxdoc.malloc(@pxdoc, sizeof(PXVAL_T), 'Allocate memory for pxval_t');
  FillChar(Result, sizeof(PXVAL_T), 0);
end;

procedure FREE_PXVAL(pxdoc: px_doc; pxval: px_val);
begin
  pxdoc.Free(@pxdoc, @pxval);
end;

end.
